---
title: "Code documentation"
author: "Vignette Author"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(conmat)
```

## About conmat

We want to understand the spread of infectious diseases in a population. One approach to this is to use contact matrices. These give the number of expected contacts from one age group to another. For example, there might be a lot of contact between infants (ages 0-5) and parents (ages 25-45), and grandparents (age 55+) but not as much contact between teenagers (age 11 - 19) and infants. 

The amount of contact also changes depending on the settings, such as home, school, and work. At work, age groups of ages 20 - 50, will have more contact with each other, and less / little contact with people aged 70+, and below the age of 20, as the number of people in those workforces is smaller.

We have information, based on special surveys, which show the number of people who have contact with each other, in different settings, such as work, home, school, and other. These surveys have been conducted in different places in the world. Specifically, we have information on the amount of contact from a "polymod" survey, which surveyed the following countries:

-   Italy, Germany, Luxembourg, Netherlands ,Poland, United Kingdom, Finland, and Belgium

However, this is only a small number of countries in the world! We could generalise this to other countries, but they will differ in a variety of ways. These can be hard to measure and adjust for. For example, it is very common in Singapore for the elderly to live with their family, and so there will be more contact between the elderly and their children and grand children. This is less common is places like Australia, and the USA. And even within countries this can vary greatly. For example, looking at the age population structure of Alice Springs, compared to Sydney, we can see that they are very different.

```{r}
#| label: figure-pyramid
#| echo: FALSE
data_age_transform <-  bind_rows(
  abs_age_lga("Sydney (C)"),
  abs_age_lga("Alice Springs (T)")
) %>% 
  group_by(lga) %>%
  mutate(
    age_multiplier = cur_group_id(),
    age_multiplier = if_else(age_multiplier == 2,
                             1,
                             -1),
    .after = lga
  ) %>%
  mutate(population_per_capita = population / sum(population)) %>% 
  ungroup() %>%
  mutate(age = as_factor(lower.age.limit),
         population = (population * age_multiplier),
         population_per_capita = (population_per_capita * age_multiplier))
pretty_symmetric <- function(range, n = 5){
  range_1 <- c(-range[1], range[2])
  range_2 <- c(range[1], -range[2])
  
  pretty_vec_1 <- pretty(range_1)
  pretty_vec_2 <- pretty(range_2)
  
  pretty(
    c(pretty_vec_1, pretty_vec_2), 
    n = n
  )
  
}
  
  # round to nearest 10
  pop_range <- range(data_age_transform$population_per_capita)
  
  age_range_seq <- pretty_symmetric(pop_range, n = 5)
  
  
   ggplot(data_age_transform,
         aes(x = population_per_capita,
             y = age,
             fill = lga)) +
    geom_col() +
    scale_x_continuous(breaks  = age_range_seq,
                       labels = abs(age_range_seq)) +
    expand_limits(x = range(age_range_seq)) + 
    scale_fill_brewer(palette = "Dark2",
                      guide = guide_legend(
                        title = ""
                      )) +
    theme_minimal() +
    theme(legend.position = "top")
```


If we assume the same amount of contact between Sydney and Alice Springs, based on the information that we have from a countries like Germany, or the UK, then we are ignoring the very heterogeneous population information of Australia. We would be saying that both Alice Springs, and Sydney have the same population structure. This would lead to very different estimates of the amount of contact between age groups.

So how do we correct for this difference in ages? Although it would be best to conduct separate surveys in each country, and within each part of a country, these surveys are expensive, and time consuming.

One way to adjust the contact surveys, is to use information on the age population of a given place. We can then use this information to appropriately increase or decrease the amount of contact between certain age groups.

As a simple example, if we find that Sydney has 4 times the number of 20-25 year olds, compared to the UK, then we might increase the estimate of the contacts between 20-25 year olds by 4.

## How do we use conmat?

Due to the lack of data from contact surveys in the majority of countries in the world, we need to use specialised techniques to project or extrapolate contact rates. conmat uses a different approach to previous methods, employing a generalised additive model (GAM) to project or extrapolate the POLYMOD data and to predict contact rates for any age groups and obtain the age and location specific contact patterns present in the local government areas or states.

## What is a contact matrix?

The risk of transmission between two individuals could be proportional to the amount or frequency of contact between them, therefore contact patterns play a tremendous role in decoding the transmission dynamics of an infectious disease and as well as employing effective public health safeguards such as imposing school closures or lockdown measures. These contact patterns can vary across different ages as well as different locations of interaction. One way to express these patterns are in matrices, in which each element indicates the estimated number of contacts between subgroups, such as age groups, which are represented as rows and columns. The location of interactions can also be taken into account by generating these contact matrices at different settings such as workplace, home, school and so on. For example, age based contact matrix at a school allow us to determine the average number of contacts an individual in age group, A, has with another individual of the same age group or another age group, B, at the location, school. 

\

![](https://lh4.googleusercontent.com/cL3q-2uVrY4jwXOXsWpQilQf1EkTadtHKs0iGD73Gw7Xi6f3xXLTrkuCgiBFy0pafidd3G_FsKRuyeRAWc2Z4SUyXJF2SKbVAh8vmhVUML0e-giiLa8dDwm6Eqekt4Vc-SGS-_MSqDVswcaH7hSufQ){width="414"}

\
**- [ ] Why are contact matrices used? Are there alternatives?**

Can include discussion on alternative names - e.g., mixing matrices. Mossong et al., also discuss that sometimes instead of contact matrices they infer contacts through indirect observations, and were assumed to follow patterns, which were calibrated against data such as serological (lab tests - where they can tell who has been in contact with who based on the similarity of the virus DNA (I think...)), or case notification data (NOTE: I'm not really sure how they infer contact information this, do they infer that certain people visited the same place at around the same time, or do people provide information on who they have contacted recently?).

You can also simulate disease spread without contact matrices, and make different assumptions based on how disease might spread - e.g., an agent based model might have different base assumptions on how people spread COVID.

As stated in Mossong paper:

> Until now, modellers have relied on proxy measures of contacts and calibration to epidemiological data. For instance, household size, class size, transport statistics, and workplace size distribution have been used in recent models to deÔ¨Åne the contact structure [2,3,33,34].
\

**[ ] What is a contact survey?**

\
Contact surveys track the number of contacts between individuals, as well as the nature (physical or non-physical, duration of contact etc.) and location of those contacts along with the survey respondent's socio demographic characteristics, such as work status, household size, age, and so on. One such survey is the POLYMOD contact pattern study which utilises respondent filed social contact diaries from 8 European countries: Belgium, Germany, Finland, Great Britain, Italy, Luxembourg, The Netherlands and Poland in an attempt to quantify social mixing patterns. Conmat retrieves the POLYMOD survey data primarily through two functions, \`get_polymod_setting_data()\` & \`get_polymod_population()\`. 

## Helper Functions

#### abbreviate_states

-   produces the abbreviation of the state names in Australia.

#### separate_age_group

-   An internal function used within \`check_args_age_population_year()\` to separate age groups in a data set into two variables for the lower and upper age limit.

#### check_args_age_population_year

-   Internally used function within \`age_population()\` to separate age groups into its lower & upper limit and to filter the data passed to the desired year and location.

#### bin_widths

-   Internal function that takes in a numeric vector and return the differences between the values in the vector assumming the final value is the same as the penultimate value.

#### check_lga_name & check_state_name

-   Function, primarly used internally checks if the LGA/state name exists in Australia and errors if not valid.

### Data

#### abs_age_lga & abs_age_state

-   Uses the data sourced from ABS on the state and LGA wise population for different age groups for the year 2020.

-   The function first checks if the LGA/state name exists in Australia and later filters out the given LGA/ State and produces the lower limit of age group and the corresponding population in the region for the year 2020.

#### get_polymod_population

-   uses the participant data from the polymod survey as well as the age specific population data from socialmixr r package to return the age specific average population of different countries weighted by the number of participants from those countries who participated in the polymod survey.

#### get_polymod_contact_data

-   uses the contact and participant data on the desired countries from the survey and impute the missing contact ages primarily through either of the three methods such as imputation of contact ages from a uniform distribution or using the average of the ages or through removal of those participants.

-   The contact settings are then classified as "home", "school", "work" and "others" where "others" include locations such as leisure, transport or other places.

-   The participants with missing contact ages or settings are removed and the number of contacts per participant and contact age from ages 0-100 are obtained for various countries and settings.

#### get_polymod_setting_data

-   get_polymod_setting_data acts as an extension of **get_polymod_contact_data** and extracts the setting wise contact data on the desired country as a list.

### Other Important stuff

#### adjust_household_contact_matrix

-   Used primarily inside the \`predict_setting_contacts()\` function.

-   Uses the polymod per capita household size to adjust the number of household contact in the given list of 4 setting-specific synthetic contact matrices, to match the average household size in that region from the Australian Bureau of Statistics data.

-   To do so, the function calculates the ratio between expected number of other household members for the desired region from ABS data (obtained by subtracting 1 from the household size), and the average per capita household size obtained from the polymod data which was used to train the model. This ratio is then multiplied to the "home" setting which then is reflected on to "all" settings, thereby forming a new set of setting-specific synthetic contact matrices.

    > **Why is per-capita household size used?**
    >
    > We use Per-capita household size instead of mean household size in order to upweight larger household size, we need a household size that is averaged over all the people in the population rather than the mean household size which would be skewed towards extreme household sizes. We use per-capita household size as it is a more accurate reflection of the average number of household members a person in the population can have contact with.
#### get_household_size_distribution

-   The function uses \`abs_household_data\`, lga & state level data on the household size (1 to 8 ) and the number of households with that particular household size, obtained from Australian Bureau of Statistics.

-   Depending on the region level that is nation wide , state or lga , the number of people in a household of a particular household size is calculated by multiplying the number of households of a size with the household size, thus producing the household size distributions of a particular region.

- It returns a dataframe with columns: year, state, lga, household_size, and n_people. So a given row represents the number of people with that household size. 

- So running this for a given LGA returns a dataframe of the number of people in a given household size:

```{r}
hh_size_fairfield <- get_household_size_distribution(lga = "Fairfield (C)")
hh_size_fairfield
```

- And running it for a given state returns each LGA for each state - so you will still need to summarise this to get it at the state level. NOTE: Shouldn't it just collapse across state without LGA info?

```{r}
get_household_size_distribution(state = "NSW")
```

> Note : Why group by state inside the switch() ? - I think we can leave this as is.
#### per_capita_household_size

-   Uses the household size distributions on relevant state or LGA using the \`get_household_size_distribution()\` which has information on the number of people in the region with household sizes from 1 to 8 - e.g. we can use the household size distribution for Fairfield from before:

```{r}
hh_size_fairfield
```

-   Using the household size distributions , the fraction of population with a particular household size is obtained and multiplied with the household size to later produce the population-weighted average of household sizes or per capita household size.

```{r}
per_capita_household_size(
  household_data = hh_size_fairfield,
  household_size_col = household_size,
  n_people_col = n_people
)
```

NOTE - check this: This household size per capita information can then be used to adjust estimates when say calculating the next generation matrix.

### Model fitting

#### get_age_population_function

> Returns an interpolating function to get populations in 1y age increments.
-   The purpose of the function is to return a function that takes in a numeric vector and returns the interpolated population corresponding to the ages passed. For example, you can pass in an example population with the following structure - with a lower.age.limit and population column.

```{r}
example_pop <- get_polymod_population()
example_pop
```

But these ages and populations are binned every 5 years. So we can now provide a specified age and get the estimated population for that 1 year age group. First we create the new function like so

```{r}
# get function to interpolate population age distributions to 1y bins
age_population_function <- get_age_population_function(example_pop)
```

Then we can pass it a given year, or vector of years:

```{r}
age_population_function(age = 0)
age_population_function(age = 5)
sum(age_population_function(age = 0:4))
```

Notice that we get a pretty similar number of 0-4 if we sum it up, as the first row of the table:

```{r}
head(example_pop, 1)
sum(age_population_function(age = 0:4))
```


-   The function first prepares the data to fit a smoothing spline to the data for ages below the maximum age. It takes the data, arranges the lower limit of the age group to obtain the bin width/differences of the lower age limits. The mid point of the bin width is later added to the ages and the population is scaled as per the bin widths.

-   The maximum age is later obtained and the populations for different above and below are filtered out along with the sum of populations with and without maximum age.

-   A cubic smoothing spline is then fitted to the data for ages below the maximum with predictor variable as the ages with the mid point of the bins added to it where as the response variable is the log-scaled population.

-   Using the smoothing spline fit, the predicted population of ages 0 to 200 is obtained and the predicted population is adjusted further using a ratio of the sum of the population across all ages from the data and predicted population. The ratio is based on whether the ages are under the maximum age as the total population across all ages differs for ages above and below the maximum age. The maximum age population is adjusted further to drop off smoothly, based on the weights.

-   The final population is then linearly extrapolated over years past the upper bound from the data. For ages above the maximum age from data, the population is calculated as a weighted population of the maximum age that depends on the years past the upper bound. Older ages would have lower weights, therefore lower population.



#### add_modelling_features

> Features like population distribution of contact ages, school work participation as well as the offset is added on to the data using this function
-   The function takes the contact data which has information on the participants' age, contact ages, number of participants in that age group as well as the number of contacts the pair of individuals in the particular age group have. For example, below shown is the contact data in the setting "home"

```{r}
polymod_contact_data <- get_polymod_setting_data()
polymod_contact_data$home
```

-   The modelling features like the population distribution of contact ages, fraction of population in each age group that attend school/work as well as the offset according to the settings are added on to the contact data through three internal functions shown below.

##### add_population_age_to

> use interpolated population of "age_to" (contact age) & get the relative population grouped by "age_from" or participant age.
- Function uses the `get_population_function()` to add the interpolated population for different contact ages based on the population data on the region provided, through which the population distribution of contact ages is obtained.

##### add_school_work_participation

- This function adds new variables for:
    - school & work attending fraction for contact & participant ages
    - probability that a person of the other age goes to the same work/school
    - probability that a person of the other age would be in the same school year
    - weighted combination of contact population age distribution & school year probability so that if the contact is in the same school year, the weight is 1, and otherwise it is the population age fraction. This can be used as an offset, so that population age distribution can be used outside the classroom, but does not affect classroom contacts (which due to cohorting and regularised class sizes are unlikely to depend on the population age distribution).

> more explanation
##### add_offset

-   Function defines the offset variable for the model to be fitted in \`fit_single_contact_model()\`.

-   Sets separate offset for school setting when compared to the other settings such as home, work and other.

-   log(population) for settings : home, work and other. The offset for school captures cohorting of students for schools and takes the logarithm of the weighted combination of contact population age distribution & school year probability calculated in the `add_school_work_participation()`.

-   The choice of the offset is set in the model formula.

```{r, eval=FALSE,echo=TRUE}
offset_variable <- switch(
    setting,
    school = "log_contactable_population_school",
    "log_contactable_population"
  )
```

> why double offsets? : The offsets get added together when the model first fit. In addition, the setting specific offset from `offset_variable`, which is included in the GAM model as `... + offset(log_contactable_population)` is used in prediction, whereas the other offset, included as an argument in the GAM as `offset = log(participants)` is only included when the model is initially created.
#### fit_single_contact_model

- This is the workhorse of the conmat R package. It predicts the contact rate between all age bands (the contact rate between ages 0 and 1, 0 and 2, 0 and 3, and so on), for a specified setting, with specific terms being added for given settings.
- The model fit is a Generalised Additive Model (GAM). To help account for assortativity with age, where people of similar ages have more contact with each other, we include predictors `age_from`, and `age_to`. To account for intergenerational contact patterns, where parents and grandparents will interact with their children and grand children, we include a term that is the absolute difference of age_from and age_to. We also include the interaction of intergenerational contact patterns with contacts from one age with the term that is the absolute difference of age_from and age_to, and age_from. These terms are fit with a smoothing function. Specifically, the relevant code looks like this:

```r
s(age_to) + 
  s(age_from) + 
  s(abs(age_from - age_to)) + 
  s(abs(age_from - age_to), age_from)
```

- We also include predictors for the probability of attending school, and attending work. These are computed as the probability that a person goes to the same school/work, proportional to the increase in contacts due to attendance. These terms are calculated from estimated proportion of people in age groups attending school and work.
      
- Finally, we include two offset terms so that we estimate the contact rate, that is the contacts per capita, instead of the number of contacts. These offset terms are the `log(contactable_population)`, and `log(contactable_population_school)` when the model is fit to a school setting. The contactable population is estimated as the interpolated 1 year ages from the data. For schools this is the contactable population weighted by the proportion of the population attending school.

- This leaves us with a model that looks like so:

```r
 mgcv::bam(
  formula = contacts ~
    s(age_to) +
    s(age_from) +
    s(abs(age_from - age_to)) +
    s(abs(age_from - age_to), age_from) +
    school_probability +
    work_probability + 
    offset(log_contactable_population) +
    # or for school settings
    # offset(log_contactable_population_school) 
  family = stats::poisson,
  offset = log(participants),
  data = population_data
    )
```
#### fit_setting_contacts

-   fit_setting_contacts acts as an extension of fit_single_contact_model

-   fits a gam model for each setting on the survey population data & the setting wise contact data.

-   Returns a list of fitted gam models for each setting.

> fit_setting_contacts is used to fit the contact model to the polymod data which includes the setting wise polymod contact data from `get_polymod_setting_data()` and the polymod population data from `get_polymod_population()`. The model is then used to extrapolate to the data on the desired LGA/state using the `predict_setting_contacts()`.


#### predict_contacts

>`predict_contacts()` predicts the contact rate between two age populations, given some setting-specific model of contact rate and population age structure. It takes three arguments: 1) model: A single fitted model of contact rate (say from `fit_single_contact_model()`), 2) population: a dataframe of age population information, with columns indicating some lower age limit, and population, and 3), age breaks - the ages to predict to. By default, the age breaks are O-75 in 5 year groups.

As an example, if we have a model of contact rate at home, and age population structure for an LGA, say, Fairfield, in NSW:

```{r}
polymod_setting_models$home

fairfield_abs_data <- abs_age_lga("Fairfield (C)")

fairfield_abs_data
```

Then we can predict the contact rate for Fairfield from the existing contact data, say, between the age groups of 0-15 in 5 year bins for school, like so:

```{r}
fairfield_school_contacts <- predict_contacts(
  model = polymod_setting_models$school,
  population = fairfield_abs_data,
  age_breaks = c(0, 5, 10, 15)
)

fairfield_school_contacts
```

Implementation details

- This function, `predict_contacts` is used internally inside `predict_setting_contacts()`, which predicts for all settings (home, work, school, other) the expected contact rate for a given population age structure, and also optionally performs an adjustment for per capita household size. You can use `predict_contacts()` yourself, just be aware you will need to separately apply a per capita household size adjustment if you want to use that. See `adjust_household_contact_matrix` for more details.

- The population data is used to determine age range to predict contact rates, and removes ages with zero population, so we do not make predictions for ages with zero populations.

- Contact rates are predicted yearly between the age groups, using  `predict_contact_1y()`, then aggregates these predicted contacts using `aggregate_predicted_contacts()`, which aggregates the predictions back to the same resolution as the data, appropriately weighting the contact rate by the population. 

##### predict_contacts_1y

> Primary purpose of the function is to predict the number of contacts for all ages from the specified minimum to maximum ages in the desired region using it's population data obtained from `abs_age_lga()` & `abs_age_state()`.


- Internally used within `predict_contacts()`. 

-   Takes in the fitted model, population data of the region to be extrapolated on as well as the minimum and maximum ages as arguments.

-   Prediction features to make predictions on the desired population are then added using the `add_modelling_features()`. These features include the population distribution of contact ages, fraction of population in each age group that attend school/work as well as the offset according to the settings on all combinations of the participant & contact ages.

-   Uses `predict()` to make predictions as well as add the measure of uncertainty or standard error of predicted means, based on the fitted model and the data passed after adding the prediction features. 

- Returns a data frame with all combinations of participant & contact ages from the minimum and maximum ages provided along with the predicted number of contacts and the level of uncertainty. For example,

```{r}

tibble::tribble(
    ~age_from, ~age_to, ~contacts,~se_contacts,
         0,   0,   0.113,      0.00812,
         0,   1,   0.106,      0.00666,
         0,   2,   0.0995,     0.00551,
         0,   3,   0.0927,     0.00468,
         0,   4,   0.0861,     0.00413,
         0,   5,   0.0796,     0.00377,
         0,   6,   0.0736,     0.00357,
         0,   7,   0.0682,     0.00344,
         0,   8,   0.0633,     0.00334,
         0,   9,   0.0590,     0.00323
  ) 
```


##### aggregate_predicted_contacts

> Obtains the population weighted average contacts a particular age group has with another age group at a particular setting. These age groups are decided according to the age breaks passed through the function as arguments.   

- Used internally within `predict_contacts()`. 

- Uses the output from `predict_contacts_1y()` that is the predicted number of contacts for all combinations of participant & contact ages, to obtain the total number of predicted contacts each participant of a particular age has with a specific age group. This is then used to calculate average of the number of contacts the participant age group has with a specified age bracket, weighted by the population distribution of the participant age. 

- Returns a data frame with all combinations of participant & contact age groups and the population weighted average number of contacts between each age groups. For example, 

```{r}
tibble::tribble(
    ~age_group_from, ~age_group_to, ~contacts,
  "[0,5)" ,          "[0,5)"   ,        "0.557",
  "[0,5)" ,          "[5,10)"  ,        "0.449",
  "[0,5)" ,          "[10,15)" ,        "0.275",
  "[0,5)" ,          "[15,20)" ,        "0.230"
  ) 
```


#### predict_setting_contacts

- Predicts contact rates for all combinations of age groups specified by the desired age breaks, in a desired population across settings such as "home","school", "work", "other" and the combination of all settings.

- These predictions are then converted to matrix format using `predictions_to_matrix()` to produce contact matrices for all age groups combinations across different settings or location of contact. 

- Upon obtaining the contact matrices, the household contact matrix is consequently adjusted by the per capita household size of the region for which the predictions are made if provided , in order to in order to upweight larger household size. See `adjust_household_contact_matrix()` for more info.


##### predictions_to_matrix

- Helper function to convert predictions of contact rates in data frames to matrix format with the survey participant age groups as columns and contact age groups as rows.  

##### matrix_to_predictions

- Helper function to convert contact matrices to data frame format.

##### Example pipeline 

Let's predict the average contact rates for ages 0 to Inf in 5 year age breaks in all settings for the NSW LGA, Fairfield 


- Extract the polymod survey population & contact data
 
```{r, eval=FALSE}
polymod_contact_data <- get_polymod_setting_data()
polymod_survey_data <- get_polymod_population()
```


- Fit the contact model to the polymod data for all settings.

```{r, eval=FALSE}
set.seed(1100)
 setting_models <- fit_setting_contacts(
  contact_data_list = polymod_contact_data,
   population = polymod_survey_data
 )
```

- Obtain the age wise population of Fairfield.

```{r}
fairfield_age_pop <- abs_age_lga("Fairfield (C)")
fairfield_age_pop

```

- Obtain the per capita household size of Fairfield 

```{r}

fairfield_hh_size <- get_per_capita_household_size(lga = "Fairfield (C)")
fairfield_hh_size
```


- Extrapolate the fitted model to the Fairfield population data. Predict the contact ages for all combinations of ages in 5 year ages breaks from 0 to 85-Inf. 


```{r, eval=FALSE}

synthetic_settings_5y_fairfield_hh <- predict_setting_contacts(
  population = fairfield_age_pop,
  contact_model = setting_models,
  age_breaks = c(seq(0, 85, by = 5), Inf),
  per_capita_household_size = fairfield_hh_size
)
```


#### extrapolate_polymod

> Allows to fit all-of-polymod model and extrapolate to a given population and age breaks with optional adjustment to the household contact matrix. 

- Uses `estimate_setting_contacts()` to fit a contact model on the data from polymod and later extrapolate on to a desired population. 

##### estimate_setting_contacts 

- Utilises the inbuilt `fit_setting_contacts()` & polymod survey contact & population data to fit a contact model on the polymod data and extrapolate the fitted model to a desired population and age breaks using the `predict_setting_contacts()`. The predicted household contact matrix can also be adjusted optionally by the region's per-capita household size. 

#### get_setting_transmission_matrices

#### generate_ngm

#### apply_vaccination

### Plotting

#### plot_matrix

#### plot_setting_matrices

