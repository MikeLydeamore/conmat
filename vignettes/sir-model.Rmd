---
title: "SIR modelling with `conmat`"
output: rmarkdown::html_vignette
vignette: >
    %\VignetteIndexEntry{sir-model}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---
```{r, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>"
)
```

```{r setup}
library(conmat)
library(deSolve)
library(tidyr)
library(ggplot2)
library(dplyr)
```

# An SIR Model with homogenous mixing

We start with a complicated version of a relatively simple model: an age-stratified SIR Model, but with all age groups acting exactly the same.

We will use 17 age groups, each in 5 year age bands, and turn these into a `conmat_population` object.

```{r}
homogeneous_population <- data.frame(
    population = rep(100, times = 9),
    age = seq(0, 80, by = 10)
) |>
    as_conmat_population(
        age = age,
        population = population
    )
```

Then, we extrapolate these into a set of contact matrices, but instead of using the estimates from POLYMOD, we overwrite them so all the entries are exactly the same.

```{r}
age_breaks_0_80_plus <- c(seq(0, 80, by = 10), Inf)
homogeneous_contact <- extrapolate_polymod(
    population = homogeneous_population,
    age_breaks = age_breaks_0_80_plus
)
# Relative number of contacts between individuals in 2 age categories
# Think of as P(contact)
homogeneous_contact$home <- matrix(1, nrow = 9, ncol = 9)
homogeneous_contact$work <- matrix(1, nrow = 9, ncol = 9)
homogeneous_contact$school <- matrix(1, nrow = 9, ncol = 9)
homogeneous_contact$other <- matrix(1, nrow = 9, ncol = 9)
```

```{r}
transmission_matrix <- get_setting_transmission_matrices(
    age_breaks = age_breaks_0_80_plus
)
transmission_matrix$home <- matrix(0.5, nrow = 9, ncol = 9)
transmission_matrix$work <- matrix(0.5, nrow = 9, ncol = 9)
transmission_matrix$school <- matrix(0.5, nrow = 9, ncol = 9)
transmission_matrix$other <- matrix(0.5, nrow = 9, ncol = 9)
```

We also need to set up our population structures. We'll have all the S states, then I, then R. Since we're using `deSolve` to solve this system, we need to make sure this order stays the same throughout!

```{r initial-condition}
S0 <- rep(999, times = 9)
I0 <- rep(1, times = 9)
R0 <- rep(0, times = 9)
initial_condition <- c(S0, I0, R0)
names(initial_condition) <- paste(rep(c("S0", "I0", "R0"), each = 9), age_breaks_0_80_plus[1:9], sep = "_")
```


For an SIR model, we need to compute the *force of infection*, which is
$$\lambda(t) = \beta I(t).$$ The $\beta$ term is the product of the probability of infection given contact, and the probability of contact, for which we can use the matrices we have just defined.

```{r}
parameters <- list(
    "transmission_matrix" = transmission_matrix,
    "homogeneous_contact" = homogeneous_contact,
    "gamma" = 1,
    "s_indexes" = 1:9,
    "i_indexes" = 10:18,
    "r_indexes" = 19:27
)

agestructured_sir <- function(time, state, parameters) {
    # Calculate the force of infection for each setting:
    # unstructured SIR beta is age_group_n / pop_n
    #
    lambda_home <- (parameters[["transmission_matrix"]]$home * parameters[["homogeneous_contact"]]$home) %*% state[parameters[["i_indexes"]]]

    lambda_work <- (parameters[["transmission_matrix"]]$work * parameters[["homogeneous_contact"]]$work) %*% state[parameters[["i_indexes"]]]

    lambda_school <- (parameters[["transmission_matrix"]]$school * parameters[["homogeneous_contact"]]$school) %*% state[parameters[["i_indexes"]]]

    lambda_other <- (parameters[["transmission_matrix"]]$other * parameters[["homogeneous_contact"]]$other) %*% state[parameters[["i_indexes"]]]

    # Combine them all into one term for ease of computation
    lambda_total <- lambda_home + lambda_work + lambda_school + lambda_other

    N <- sum(state)

    # Don't forget to normalise your infection rate by the population!
    dSdt <- -lambda_total * state[parameters[["s_indexes"]]] / N
    dIdt <- lambda_total / N * state[parameters[["s_indexes"]]] - parameters[["gamma"]] * state[parameters[["i_indexes"]]]
    dRdt <- parameters[["gamma"]] * state[parameters[["i_indexes"]]]

    return(list(c(dSdt, dIdt, dRdt)))
}
```

```{r solve-ode-homogeneous}
times <- seq(0, 20, by = 0.1)
homogeneous_soln <- ode(y = initial_condition, times = times, func = agestructured_sir, parms = parameters)

# Have to convert ode output to a data frame to do any plotting
homogeneous_soln <- as.data.frame(homogeneous_soln)

head(homogeneous_soln)
```

Now, let's compare this to an SIR model with no stratification:

```{r standard-sir}
parameters_sir <- c("beta" = 2, "gamma" = 1)
initial_condition_sir <- c("S" = 8991, "I" = 9, "R" = 0)

sir <- function(time, state, parameters) {
    N <- sum(state)
    lambda_total <- parameters["beta"] * state["I"]
    dSdt <- -lambda_total / N * state["S"]
    dIdt <- parameters["beta"] / N * state["S"] * state["I"] - parameters["gamma"] * state["I"]
    dRdt <- parameters["gamma"] * state["I"]

    return(list(c(dSdt, dIdt, dRdt)))
}

sir_soln <- ode(y = initial_condition_sir, times = times, func = sir, parms = parameters_sir)
sir_soln <- as.data.frame(sir_soln)

head(sir_soln)
```

```{r plot-standard-sir}
ungrouped_structure <- sir_soln %>%
    pivot_longer(!time) %>%
    mutate(type = "Non-structured")

# For the stratified model, we have to add up all the age categories together for a fair comparison.
grouped_structure <- homogeneous_soln %>%
    pivot_longer(!time) %>%
    mutate(parent_state = substr(name, 1, 1)) %>%
    group_by(time, parent_state) %>%
    summarise(value = sum(value)) %>%
    ungroup() %>%
    rename(name = parent_state) %>%
    mutate(type = "Age structured")

combined_solutions <- rbind(ungrouped_structure, grouped_structure)
combined_solutions$name <- factor(combined_solutions$name, levels = c("S", "I", "R"))

combined_solutions
```

```{r plot-both-models}
ggplot(combined_solutions, aes(x = time, y = value, colour = name, linetype = type)) +
    geom_line() +
    labs(x = "Time", y = "Value", colour = "State", linetype = "Model")
```

Voila! These lines are the same. So, we have successfully collapsed our stratified model down to the non-stratified model, which is a great sense check for every time you write out a complicated model.